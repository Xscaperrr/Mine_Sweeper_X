# Mine_Sweeper_X 扫雷项目


## 解题思路
首先需要实现的是扫雷游戏本身的游戏逻辑。其中基本操作通过重载可以很容易实现，点到空格块爆出周围的一块的通过遍历周围的格子模拟点击也可以轻松实现。  
需要注意的是布雷算法，其本质是在C(m,n)种情况中随机选择一个。想要简单高效的实现可以使用洗牌算法，在固定位置放雷然后通过**洗牌**操作来打乱数组即可。  
然后在计算概率前首先需要能简单地确定"**定雷**"，也就是一定是雷的格子。依照个人的扫雷经验，首先有一个简单的逻辑，就是一个数字格周围的未翻开格如果等同于他自身的数字，那么这些未翻开格肯定都是雷。如果一个数字格周围的"**定雷**"数已经等同于他自身的数字，那么他周围的其他未翻开格就一定是"**定非雷**"。  
虽然人工扫雷时有更多的简单逻辑，例如看边角，记下几个格子里一定有几个雷来推断，但这些算法不够简单也不一定有效不适合机械计算，故没有采用。  
但仅凭上述逻辑显然不能标出所有的"**定雷**"和"**定非雷**"，但也不用去有意标记了因为接下来进行的与概率计算有关操作中会顺带完成。这将在关于扫雷的古典概型基础中详细论述。现在仅仅说结论:计算场上所有未翻开格需要知道所有的可能解。因为计算解的方程过于复杂，所以本人采用最为简单粗暴的方法来列出所有解:穷举。但显然，暴力穷举会产生过多的重复计算，例如不符合游戏规则的解。所以最后采用的方法是经过优化的回溯法，这个方法其实有些类似于动态规划，但是每一步的决策基本都会影响下一步所以并没有解决重叠子问题而是消除了"**无用(不可能)子问题**"。当然，这样的话仍然存在真正的重叠子问题，即几块完全不邻接的未翻开格，这时可以先进行划分然后采用分治的思想求解，把计算量从n*m降为n+m。但本项目目前只维护了9\*9版本的扫雷，所以划分开销可能比计算量的减少还高故没有实现。
## 算法设计  
* 洗牌算法  
* 简单标雷  
为了实现上述逻辑,首先需要遍历所有格子,找到所有的数字格，然后需要维护一个"**活跃数字格**"链表，重复遍历整个链表按照上述逻辑标雷，动态删去已经不活跃的格子并且记录一次遍历中是否有无标记操作操作，直到一轮遍历中没有进行任何标记操作停止遍历。
* 经过优化的回溯法

* 概率计算:  
Step1:遍历所有有数字的块标记出确定的雷和确定的非雷  
Step2:如果第一步标记出了雷和非雷，则重复第一步，直至不能直接确定任何块的状态  
Step3:将现有的不确定块分为不可知和可知两部分(通过周围八格是否有数字),穷举可知雷区获得所有可能解法  
Step4:列出可知区所有可能雷数，通过排列组合计算各个可能雷数概率，再将每个解法的概率代 入，计算最终概率
